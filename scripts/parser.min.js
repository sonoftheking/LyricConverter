var parser = (function(){

	var utilities = {
		decode: function(str){
			var decoded = window.atob( str );
			try{
				return decodeURIComponent(escape(decoded));
			}catch(ex){
				return decoded;
			}
		},
		encode:function(str){
			return window.btoa(unescape(encodeURIComponent( str )));
		}
	}

	function parseFile(i, fileObj){
		var data = fileObj.data;
		var fullFileName = fileObj.name;

		try{
			//Find the file extention
			var fileParts = fullFileName.split(".");
			var fileName = fileParts[0];
			var fileExt = fileParts.slice(-1)[0].toLowerCase();

			//Test the file extension with the test function registered with each format type
			//When one matches, use that formats convert function
			var convertFn;
			$.each(parser.formats, function(format, formatObj){
				if(formatObj.testExtension(fileExt)){
					convertFn = formatObj.convert;
					return false;
				}
			});

			//Make sure the convert function exists...
			if($.isFunction(convertFn)){
				//Browsers will add some unneeded text to the base64 encoding. Remove it.
				var encodedSongData = data.replace(/^data:.*;base64,/,"");
				var decodedSongData = utilities.decode(encodedSongData);

				//Pass the decoded song date to the convert function
				//We will get back a normalized version of the song content for the supported file type
				parser.songList.push({
					name: fileName,
					data: convertFn(decodedSongData, fileName)
				});

			}else{
				parser.errorList.push("The file <strong>"+fullFileName+"</strong> cannot be parsed because <strong>."+fileExt.toUpperCase()+"</strong> files are not supported!")
			}
		}catch(ex){
			parser.errorList.push("There was an error reading the file <strong>"+fullFileName+"</strong>");
		}
	}

	function complete($outputContainer){
		if(parser.songList.length){
			//Pass the final song data to the selected output type
			parser.outputs[parser.outputFormat]($outputContainer, parser.songList);
		}
	}

	return {
		//Expose functions publicly
		utilities: utilities,
		parseFile: parseFile,
		complete: complete,
		outputFormat: null,
		
		//UI properties should be filled in when this is run
		displayError: null,
		songList:[],
		errorList:[],

		//These objects will be filled in when formatter & output files are run
		formats:{},
		outputs:{}
	}
})();

/* **********************************************
     Begin formats.songshowplus.js
********************************************** */

/*=====================================================
 * PARSER for SongShowPlus files
 * Extension: .sbsong
 * Site: http://www.songshowplus.com/
=======================================================*/

(function () {

	var THIS_FORMAT = 'songshowplus';
	parser.formats[THIS_FORMAT] = {};

	parser.formats[THIS_FORMAT].testExtension = function(fileExt){
		return /sbsong/i.test(fileExt);
	};

	//Extend the formats object on the parser to allow for parsing SongShowPlus files
	parser.formats[THIS_FORMAT].convert = function(songData, fileName){
		//We don't want any properties XML tags which can sometimes begin the file.
		//Splitting these out and then taking teh first array item can prevent this.
		//Each song sections seems to be split up by a percent sign, so make an array by splitting on that
		var sections = songData.split("<Properties>")[0].split("%");

		//Pass all the sections in here to get the lyrics
		//We will get out the slides and the keywords
		var slideContent = _getSlides(sections);

		//The info is all contained in the first section, so only pass that in and pass in teh keywords from above
		var parsedInfo = _getInfo(sections[0], slideContent.keywords, fileName);

		//Return the filled in song object
		return {
			title: parsedInfo.title,
			info: parsedInfo.info,
			slides: slideContent.slides
		};
	};

	//===================================
	//PRIVATE FUNCTIONS
	//===================================

	//Regex pattern AS A STRING to match invisible control characters
	//Slashes are double escaped here so it can be in a string!
	var _patternInvisiblesStr = "[\\xA0\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F]";
	//Same pattern, but as a real RexExp object
	var _invisibles = new RegExp(_patternInvisiblesStr);

	function _getInfo (firstSection, keywords, fileName) {
		//Split the info up into an array by the invisible characters
		var infoArray = firstSection.split(_invisibles);
		
		//Now loop through the array and remove all empty items and items that are only 1 character long
		infoArray = $.grep(infoArray,function(n){
			var item = $.trim(n).replace(/\r\n\t/g,"");
			return item.length>1 ? item : false;
		});

		//If the first items is a number between 1 and 4 digits, remove it
		if(/[0-9]{1,4}/.test(infoArray[0])){
			infoArray.splice(0,1);
		}

		//Make sure the title is filled in, if not use the filename
		var songTitle = (infoArray[0].length > 0) ? infoArray[0] : fileName;

		var songInfo = [];

		songInfo.push({
			'name':'Artist/Author',
			'value':infoArray[1]
		});

		//If the copyright exists, add it
		if(infoArray[2]){
			songInfo.push({
				'name':'Copyright',
				'value':infoArray[2].replace("$","") //copyright info tends to end with a $ sign, so remove it
			});
		}

		//If the CCLI exists, add it
		if(infoArray[3]){
			songInfo.push({
				'name':'CCLI',
				'value':infoArray[3]
			});
		}

		//If we have keywords, add them
		if(keywords){
			songInfo.push({
				'name':'Keywords',
				'value':keywords
			});
		}

		return {
			'info': songInfo,
			'title': songTitle
		};
	}

	function _getSlides (sections) {
		//Sections tend to begin with N number of control characters, a random print character, more control characters, and then the title "Verse 1" or soemthing
		//After that is the actual song lyrics, but it may be preceeded by one non-word character
		//Slashes are double escaped here so it can be in a string!
		var slidePattern = new RegExp("^" + _patternInvisiblesStr + "+.{1}" + _patternInvisiblesStr + "+(.+)" + _patternInvisiblesStr + "+\\W*([\\s\\S]+)", "m");

		var slideArray = [];

		//Loop through the sections, but SKIP the first one since it contains the song info we don't need here
		for (var i = 1; i < sections.length; i++) {
			
			//Run the regex on each section to split out the slide title from the lyrics
			var matches = sections[i].match(slidePattern);

			//Remove whitespace from the title
			var slideTitle = $.trim(matches[1]).replace(_invisibles, "");

			//Remove any more invisibles from the lyrics and remove whitespace
			var slideLyrics = $.trim(matches[2]).replace(_invisibles, "");
			
			//Save it to the array!
			slideArray.push({
				"title": slideTitle,
				"lyrics": slideLyrics
			});
		}

		//The last slide also contains the keywords, we need to parse these out separately
		var lastSlideObj = _getKeywordsFromLastSlide(sections.slice(-1)[0]);
		var keywords = false;
		if(lastSlideObj){
			keywords = lastSlideObj.keywords;
			slideArray.slice(-1)[0].lyrics = lastSlideObj.lastLyrics;
		}

		return {
			'slides': slideArray,
			'keywords': keywords
		};
	}

	function _getKeywordsFromLastSlide(lastSlideRaw) {

		var infoArray = lastSlideRaw.split(_invisibles);
		//Now loop through the array and remove all empty items and items that are only 1 character long
		infoArray = $.grep(infoArray,function(n){
			var item = $.trim(n);
			return item.length>1 ? item : false;
		});

		//If we have at least 3 sections, then we have keywords
		if(infoArray.length>2){
			//The keywords are the entire array except for the first two items
			var keywords = infoArray.splice(2).join(", ").replace(/\r\n\t/g,"");

			//Return the last slide minus the keywords, then parse out the optional begining non-word character
			var lastLyrics = infoArray[1].match(/^\W*([\s\S]+)/m)[1];

			return{
				'keywords': keywords,
				'lastLyrics': lastLyrics
			};
		}

		//We have nothing to return!
		return false;
		
	}

})();

/* **********************************************
     Begin formats.propresenter.js
********************************************** */

/*=====================================================
 * PARSER for ProPresenter 4 files
 * Extension: .pro4
 * Site: http://www.renewedvision.com/propresenter.php
=======================================================*/

(function () {

	var THIS_FORMAT = 'propresenter';
	parser.formats[THIS_FORMAT] = {};

	parser.formats[THIS_FORMAT].testExtension = function(fileExt){
		return /pro\d+/i.test(fileExt);
	};

	//Extend the formats object on the parser to allow for parsing ProPresenter files
	parser.formats[THIS_FORMAT].convert = function(songData, fileName){
		
		//select the top-level document element
		var $presentationDoc = $(songData);

		//Collect all the attributes to parse later
		var attrs = $presentationDoc.get(0).attributes;
			
		//Collect all the sides to parse later
		var $slides = $presentationDoc.children("slides").children();

		//Make sure the title is filled in, if not use the filename
		var songTitle = (typeof attrs.cclisongtitle === "string" && attrs.cclisongtitle.length > 0) ? attrs.cclisongtitle.value : fileName;

		//Fill in the filled-in song object
		return {
			title: songTitle,
			info: _getInfo(attrs),
			slides: _getSlides($slides)
		};
	};

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _getSlides($slides){
		var songSlides = [];

		//Loop through all the passed in slides
		$slides.each(function(i, el){
			var $thisSlide = $(el);

			var labelText = $.trim($thisSlide.attr("label"));

			//Grab the base64 encoded data from the slide element, decode it, the strip off the RTF formatting
			var encodedRtfData = $thisSlide.find("rvtextelement").attr("rtfdata");
			var decodedRtfData = parser.utilities.decode(encodedRtfData);
			var lyricsText = _stripRtf(decodedRtfData);

			songSlides.push({
				"title":labelText,
				"lyrics":lyricsText
			});
		});

		return songSlides;
	}

	function _getInfo(infoAttributes){
		//An array of attributes that we don't need to display in the UI
		var itemsToRemove = ['height','width','cclisongtitle','cclidisplay','versionnumber','doctype','creatorcode','lastdateused', 'usedcount','backgroundcolor','drawingbackgroundcolor'];

		var songInfo = [];

		//Loop through all the passed in attributes
		$.each(infoAttributes, function(i, thisAttr){

			//Continue only if the attribute is not in the array above AND the value is not blank
			if($.inArray(thisAttr.name, itemsToRemove) < 0 && thisAttr.value !== ""){
				songInfo.push({
					"name": thisAttr.name,
					"value": thisAttr.value
				});
			}
		});

		//Special case - Set the date. Parse it to a human readable date!
		var lastUsedDate = new Date(Date.parse(infoAttributes.lastdateused.value));
		if(!isNaN(lastUsedDate.getTime())){
			songInfo.push({
				"name": "Last Used On",
				"value":lastUsedDate
			});
		}

		return songInfo;
	}

	function _stripRtf(str){
		//var pattern = /\{\*?\\[^{}]+}|[{}]|\\\n?[A-Za-z]+\n?(?:-?\d+)?[ ]?/g;
		var basicRtfPattern = /\{\*?\\[^{}]+}|[{}]|\\[A-Za-z]+\n?(?:-?\d+)?[ ]?/g;
		var newLineSlashesPattern = /\\\n/g;

		var stripped = str.replace(basicRtfPattern,"");
		var removeNewlineSlashes = stripped.replace(newLineSlashesPattern, "\n");
		var removeWhitespace = removeNewlineSlashes.trim();

		return removeWhitespace;
	}
})();

/* **********************************************
     Begin outputs.propresenter.js
********************************************** */

/*=====================================================
 * OUTPUT for converting to ProPresenter format
=======================================================*/

(function(){
	var THIS_OUTPUT = 'propresenter';
	var FILE_EXTENSION = ".pro4";

	//Extend the outputs object on the parser to allow for HTML output
	parser.outputs[THIS_OUTPUT] = function ($container, songList) {

		//Loop through and convert each file and add the 
		var convertedFileContents=[];
		var errorFiles = [];
		$.each(songList, function(i, song) {
			try{
				convertedFileContents.push({
					name: song.name,
					data: _makeProPresenterFile(song.data)
				});
			}catch(ex){
				errorFiles.push(song.name);
			}
		});

		//Display any errors if we have them
		if(errorFiles.length){
			parser.displayError(errorFiles.join(", "), "Error converting the following " + errorFiles.length + " songs!");
		}

		_displaySuccessHtml($container, convertedFileContents);
	}

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _makeProPresenterFile(songData){
		
		var ppDoc = _getPPDocBegin(songData);

		for (var i = 0; i < songData.slides.length; i++) {
			var slide = songData.slides[i];

			ppDoc += _makeSlide(i, slide.title, slide.lyrics);
		};

		ppDoc += '</slides><timeline timeOffSet="0" selectedMediaTrackIndex="0" unitOfMeasure="60" duration="0" loop="0"><timeCues containerClass="NSMutableArray"></timeCues><mediaTracks containerClass="NSMutableArray"></mediaTracks></timeline><bibleReference containerClass="NSMutableDictionary"></bibleReference></RVPresentationDocument>';;

		return ppDoc;

	}

	function _getPPDocBegin(songData){
		var keywords = '';
		var artist = '';
		var author = '';
		var year = '';
		var copyright = '';
		var ccli = '';

		var now = new Date();
		var todaysDate = now.getFullYear()+"-"+now.getMonth()+"-"+now.getDate()+"T"+now.getHours()+":"+now.getMinutes()+":"+now.getSeconds();

		//Loop through each info item and fill in the correct value if it exists
		for (var i = 0; i < songData.info.length; i++) {
			var info = songData.info[i];

			if(/copyright/i.test(info.name)){
				var ccMatches = info.value.match(/(\d{4})(.*)/);
				if(ccMatches){
					if(ccMatches.length>1) year = ccMatches[1];
					if(ccMatches.length>2) copyright = ccMatches[2];
				}else{
					copyright = info.value;
				}
			}else if(/ccli/i.test(info.name)){
				ccli = info.value;
			}else if(/keywords/i.test(info.name)){
				keywords = info.value;
			}else if(/author|artist/i.test(info.name)){
				artist = info.value;
				author = info.value;
			}
		};

		//Return the document beginning stringnew 
		return '<RVPresentationDocument height="768" width="1024" versionNumber="400" docType="0" creatorCode="1349676880" lastDateUsed="' + todaysDate + '" usedCount="0" category="Song" resourcesDirectory="" backgroundColor="0 0 0 1" drawingBackgroundColor="0" notes="' + keywords + '" artist="' + artist + '" author="' + author + '" album="" CCLIDisplay="0" CCLIArtistCredits="" CCLISongTitle="' + songData.title + '" CCLIPublisher="' + copyright + '" CCLICopyrightInfo="' + year + '" CCLILicenseNumber="' + ccli + '"><slides containerClass="NSMutableArray">';
	}

	function _generateUniqueID(){
		//Native PP ID Example: 26AAF905-8F45-4252-BFAB-4C10CCFE1476

		function s4() {
		  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
		};

		return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	}
	
	function _makeBlankSlide(order){
		return '<RVDisplaySlide backgroundColor="0 0 0 0" enabled="1" highlightColor="0 0 0 0" hotKey="" label="" notes="" slideType="1" sort_index="' + order + '" UUID="'+_generateUniqueID()+'" drawingBackgroundColor="0" serialization-array-index="' + order + '"><cues containerClass="NSMutableArray"></cues><displayElements containerClass="NSMutableArray"></displayElements></RVDisplaySlide>';
	}
	
	function _makeSlide(order, label, text){
		//Returns white Helvetica text in RTF format and then Base64 encoded
		//var fakeRTF="{\\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320{\\fonttbl\\f0\\fswiss\\fcharset0 Helvetica;}{\\colortbl;\\red255\\green255\blue255;}\pard\\tx560\\tx1120\\tx1680\\tx2240\\tx2800\\tx3360\\tx3920\\tx4480\\tx5040\\tx5600\\tx6160\\tx6720\qc\pardirnatural\\f0\\fs96 \cf1 "+ text.replace("\n","\\\n")+"}";

		var fakeRTF = ['{\\rtf1\\ansi\\ansicpg1252\\cocoartf1038\\cocoasubrtf320',
			'{\\fonttbl\\f0\\fswiss\\fcharset0 Helvetica;}',
			'{\\colortbl;\\red255\\green255\\blue255;}',
			'\\pard\\tx560\\tx1120\\tx1680\\tx2240\\tx2800\\tx3360\\tx3920\\tx4480\\tx5040\\tx5600\\tx6160\\tx6720\\qc\\pardirnatural',
			'',
			'\\f0\\fs96 \\cf1 '+ text.replace(/\r\n/g,"\\\n")+'}'].join("\n");

		var encodedRtf = parser.utilities.encode(fakeRTF)

		//console.log(encodedRtf);

		var slideXML = ['',
		'<RVDisplaySlide backgroundColor="0 0 0 0" enabled="1" highlightColor="0 0 0 0" hotKey="" label="' + label + '" notes="" slideType="1" sort_index="' + order + '" UUID="'+ _generateUniqueID() + '" drawingBackgroundColor="0" serialization-array-index="' + order+'">',
		'	<cues containerClass="NSMutableArray"></cues>',
		'	<displayElements containerClass="NSMutableArray">',
		'		<RVTextElement displayDelay="0" displayName="Default" locked="0" persistent="0" typeID="0" fromTemplate="0" bezelRadius="0" drawingFill="0" drawingShadow="0" drawingStroke="0" fillColor="1 1 1 1" rotation="0" source="" adjustsHeightToFit="0" verticalAlignment="0" RTFData="' + encodedRtf + '" serialization-array-index="0">',
		'			<_-RVRect3D-_position x="20" y="20" z="0" width="984" height="728"></_-RVRect3D-_position>',
		'			<_-D-_serializedShadow containerClass="NSMutableDictionary">',
		'				<NSCFNumber serialization-native-value="5" serialization-dictionary-key="shadowBlurRadius"></NSCFNumber>',
		'				<NSCalibratedRGBColor serialization-native-value="0 0 0 0.5" serialization-dictionary-key="shadowColor"></NSCalibratedRGBColor>',
		'				<NSCFString serialization-native-value="{3.53553, -3.53553}" serialization-dictionary-key="shadowOffset"></NSCFString>',
		'			</_-D-_serializedShadow>',
		'			<stroke containerClass="NSMutableDictionary">',
		'				<NSCachedRGBColor serialization-native-value="0 0 0 1" serialization-dictionary-key="RVShapeElementStrokeColorKey"></NSCachedRGBColor>',
		'				<NSCFNumber serialization-native-value="1" serialization-dictionary-key="RVShapeElementStrokeWidthKey"></NSCFNumber>',
		'			</stroke>',
		'		</RVTextElement>',
		'	</displayElements>',
		'</RVDisplaySlide>'].join("\n");

		return slideXML;
	}

	function _displaySuccessHtml($container, convertedFileContents){
		//Display any successes if we have them
		if(convertedFileContents.length > 0){
			//Make some unique ID's we can select on later
			var downloadZipId = "btn-"+THIS_OUTPUT+"-download-zip";
			var downloadFilesId = "btn-"+THIS_OUTPUT+"-download-files";

			//Build up some HTML to write out
			var finalHtml = "<h1>Converted " + convertedFileContents.length + " Song File" + (convertedFileContents.length>1?"s":"") + "!</h1>";
			if(convertedFileContents.length > 1){
				finalHtml += "<button id='"+downloadZipId+"' type='button' class='btn btn-large btn-primary'>Download as .zip</button>";	
				finalHtml += " or <button id='"+downloadFilesId+"' type='button' class='btn'>Download "+convertedFileContents.length + " individual files</button>";
			}else{
				finalHtml += "<button id='"+downloadFilesId+"' type='button' class='btn btn-large btn-primary'>Download file</button>";
			}
			
			//Write the HTML to the page
			$container.html(finalHtml);

			//Add click events to each button we added above
			$("#"+downloadZipId).on("click",function(){
				
				//Create a new .ZIP archive
				var zip = new JSZip();

				//Go through and add each fiel to the zip
				$.each(convertedFileContents, function(i, convertedSong) {
					zip.file(convertedSong.name + FILE_EXTENSION, convertedSong.data)
				});

				//Generate the zip file contents
				var zipContent = zip.generate({type:"blob"});
				//Download it!
				saveAs(zipContent, "converted files.zip");
			});

			$("#"+downloadFilesId).on("click",function(){
				$.each(convertedFileContents, function(i, convertedSong) {
					var fileBlob = new Blob([convertedSong.data], {type: "text/xml;charset=utf-8"});
					saveAs(fileBlob, convertedSong.name + FILE_EXTENSION);
				});
			});
		}
	}
})();

/* **********************************************
     Begin outputs.text.js
********************************************** */

/*=====================================================
 * OUTPUT for converting to Text format
=======================================================*/

(function(){
	var THIS_OUTPUT = 'text';
	var FILE_EXTENSION = ".txt";

	//Extend the outputs object on the parser to allow for HTML output
	parser.outputs[THIS_OUTPUT] = function ($container, songList) {

		//Loop through and convert each file and add the 
		var convertedFileContents=[];
		var errorFiles = [];
		$.each(songList, function(i, song) {
			try{
				convertedFileContents.push({
					name: song.name,
					data: _makeTextFile(song.data)
				});
			}catch(ex){
				errorFiles.push(song.name);
			}
		});

		//Display any errors if we have them
		if(errorFiles.length){
			parser.displayError(errorFiles.join(", "), "Error converting the following " + errorFiles.length + " songs!");
		}

		_displaySuccessHtml($container, convertedFileContents);
	}

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _makeTextFile(songData){
		
		var txtFile = "Title: " + songData.title;

		//Loop through the song info attributes
		for (var i = 0; i < songData.info.length; i++) {
			var info = songData.info[i];
			if(info.name && info.value){
				txtFile += "\r\n";
				txtFile += info.name + ": " + info.value;
			}
		}

		txtFile += "\r\n\r\n";

		//Add the song lyrics
		for (var i = 0; i < songData.slides.length; i++) {
			var slide = songData.slides[i];

			txtFile += slide.title;
			txtFile += "\r\n";
			txtFile += slide.lyrics;

			if(i < songData.slides.length-1){
				txtFile += "\r\n\r\n";
			}
		};

		return txtFile;

	}

	function _displaySuccessHtml($container, convertedFileContents){
		//Display any successes if we have them
		if(convertedFileContents.length > 0){
			//Make some unique ID's we can select on later
			var downloadZipId = "btn-"+THIS_OUTPUT+"-download-zip";
			var downloadFilesId = "btn-"+THIS_OUTPUT+"-download-files";

			//Build up some HTML to write out
			var finalHtml = "<h1>Converted " + convertedFileContents.length + " Song File" + (convertedFileContents.length>1?"s":"") + "!</h1>";
			if(convertedFileContents.length > 1){
				finalHtml += "<button id='"+downloadZipId+"' type='button' class='btn btn-large btn-primary'>Download as .zip</button>";	
				finalHtml += " or <button id='"+downloadFilesId+"' type='button' class='btn'>Download "+convertedFileContents.length + " individual files</button>";
			}else{
				finalHtml += "<button id='"+downloadFilesId+"' type='button' class='btn btn-large btn-primary'>Download file</button>";
			}
			
			//Write the HTML to the page
			$container.html(finalHtml);

			//Add click events to each button we added above
			$("#"+downloadZipId).on("click",function(){
				
				//Create a new .ZIP archive
				var zip = new JSZip();

				//Go through and add each fiel to the zip
				$.each(convertedFileContents, function(i, convertedSong) {
					zip.file(convertedSong.name + FILE_EXTENSION, convertedSong.data)
				});

				//Generate the zip file contents
				var zipContent = zip.generate({type:"blob"});
				//Download it!
				saveAs(zipContent, "converted files.zip");
			});

			$("#"+downloadFilesId).on("click",function(){
				$.each(convertedFileContents, function(i, convertedSong) {
					var fileBlob = new Blob([convertedSong.data], {type: "text/xml;charset=utf-8"});
					saveAs(fileBlob, convertedSong.name + FILE_EXTENSION);
				});
			});
		}
	}
})();

/* **********************************************
     Begin outputs.display.js
********************************************** */

/*=====================================================
 * OUTPUT for displaying slide content in the browser as HTML
=======================================================*/

(function(){
	var THIS_OUTPUT = 'display';

	//Extend the outputs object on the parser to allow for HTML output
	parser.outputs[THIS_OUTPUT] = function ($container, songList) {
		
		$.each(songList, function(i, song){
			//Create some slides with the normalized song data
			var $song = $(_createSlides(song.data))
			$container.append($song);

			//Now make all the slides have the same height
			_equalSlideHeights($song);
		});
	}

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _createSlides(songData){

		var htmlOutput = '<h3 class="song-title">'+songData.title+'</h3>';
		htmlOutput += '<ul class="song-info">';
		

		//Add each info item
		for (var i = 0; i < songData.info.length; i++) {
			var s = songData.info[i];
			htmlOutput += '<li><strong>'+s.name+':</strong> '+s.value+'</li>';
		};

		htmlOutput += '</ul><ul class="slides-container thumbnails">';

		//Output the slides themselves
		for (var i = 0; i < songData.slides.length; i++) {
			var s = songData.slides[i];
			//If the title is blank, add a space character so it look even
			var title = s.title.length < 1 ? '&nbsp;' : s.title;
			//Create a new HTML clide and add it to the DOM
			htmlOutput += '<li class="span3"><div class="thumbnail slide-content"><p class="slide-lyrics">'+s.lyrics+'</p><h6 class="slide-label">'+title+'</h6></div></li>';
		};

		htmlOutput += '</ul>'

		return htmlOutput;
	}

	function _equalSlideHeights($scope){
		var currentTallest = 0;

		$scope
			.find('.slide-lyrics')
			.each(function(i){
				if ($(this).height() > currentTallest) {
					currentTallest = $(this).height();
				}
			})
			.css({'min-height': currentTallest}); 
	}
})();